import os

from stat import S_ISREG, ST_CTIME, ST_MODE
import os, sys, time
import mmap

import contextlib

import argparse

from Evtx.Evtx import FileHeader

from Evtx.Views import evtx_file_xml_view
import time
treestore=[]
searchfor='' # nouse
strr=''

searchitem='' # stores the actual suspicious pid

processidtodelete=[]
processname=[]

getparentname=''
count=1

treefromsysmonready=0

deletedbyprocmon=0
deletedbyhandles=0

def processme2tree(line):
	global searchitem,processname,processidtodelete,getparentname,count
	#print 'searchitem:',searchitem
	splitinfo=line.split('_$#_')
	foundsearchitem=0
	if count==1:
		kl=splitinfo[0]
		try:
			kl.index(searchitem)
			foundsearchitem=1
		except:
			pass
	elif count==0:
		kl=splitinfo[0]
		try:
			if kl==searchitem:
				foundsearchitem=1
		except:
			pass
	if foundsearchitem==1 and count==1: # first time
		processidtodelete.append(splitinfo[0])
		processname.append(splitinfo[1])
		processidtodelete.append(splitinfo[2])
		processname.append(splitinfo[3])
		#getparentname=splitinfo[3]
		#getparentname=getparentname.split(os.sep)# this get the name
		#getparentname=getparentname[len(getparentname)-1]
		getparentname=splitinfo[2] # its better to get the parent id
		searchitem=getparentname
		#print '---------------------------------------'
		#print line
		#print '-----'
		#print searchitem
		#print '------------'
		#print processname
		#print '-------------------'
		#print processidtodelete
		#print '----------------------------'
		#print splitinfo
		#print '-----------------------------------'
		
		##raw_input(' ')
		count=0
	elif foundsearchitem==1 and count==0: # second time n going..
		#processidtodelete.append(splitinfo[0])
		#processname.append(splitinfo[1])
		processidtodelete.append(splitinfo[2])
		processname.append(splitinfo[3])
		#getparentname=splitinfo[3]
		#getparentname=getparentname.split(os.sep)# this get the name
		#getparentname=getparentname[len(getparentname)-1]
		getparentname=splitinfo[2] # its better to get the parent id
		searchitem=getparentname
		#print '---------------------------------------'
		#print line
		#print '-----'
		#print searchitem
		#print '------------'
		#print processname
		#print '-------------------'
		#print processidtodelete
		#print '----------------------------'
		#print splitinfo
		#print '-----------------------------------'
		##raw_input(' ')
	##print searchitem


def gettree(pid):
	global searchitem,processname,processidtodelete,getparentname,count
	processname=[]
	processidtodelete=[]
	getparentname=''
	searchitem=str(pid)
	for line in reversed(open(r'C:\ransomtesting\internals'+os.sep+"sysmonxml.exe").readlines()):
		processme2tree(line.rstrip())
	print processname
	print processidtodelete

	for kn in processidtodelete:
		print kn
		try:
			os.system('Taskkill /PID '+str(kn)+' /F')
			raw_input('Teminated successfully..')
		except Exception as ex:
			print ex
	raw_input('gettree about to return')

def maketree(xml):
	global treestore,searchfor,strr
	strr=''
	#raw_input('-=-=-=')
	#print xml
	#raw_input('=-=-=-')
	dxc=xml.split('\n')
	#print dxc
	#raw_input('######')
	#dxc=xml
	gotpid=0
	for jkk in dxc:
		#raw_input('44444')
		#print jkk
		#raw_input('77777')
		xml=str(jkk)
		##print xml
		
		
		try:
			xml.index('Qualifiers')
			strr=''
			avar=xml.split('>')
			avar=avar[1].split('<')
			avar=avar[0]
			#strr=avar+'_'
			##print xml
			##print strr
			if avar!='1':
				#print 'next event'
				#raw_input('88888')
				continue
			else:
				gotpid=1
		except Exception as ex:
			#print ex
			#print '1'
			pass
		try:
			if gotpid==1:
				xml.index('"ProcessId')
				strr=''
				avar=xml.split('>')
				avar=avar[1].split('<')
				avar=avar[0]
				strr=avar+'_$#_'
				##print xml
				#print strr
				#gotpid=1
				pass
		except Exception as ex:
			#print ex
			#print '2'
			#gotpid=0
			pass
		try:
			if gotpid==1:
				xml.index('"Image')
				avar=xml.split('>')
				avar=avar[1].split('<')
				avar=avar[0]
				strr=strr+avar+'_$#_'
				##print xml
				#print strr
		except Exception as ex:
			##print ex
			pass
		try:
			if gotpid==1:
				xml.index('ParentProcessId')
				avar=xml.split('>')
				avar=avar[1].split('<')
				avar=avar[0]
				strr=strr+avar+'_$#_'
				##print xml
				#print strr
		except Exception as ex:
			##print ex
			pass
		try:
			if gotpid==1:
				xml.index('ParentImage')
				avar=xml.split('>')
				avar=avar[1].split('<')
				avar=avar[0]
				strr=strr+avar
				treestore.append(strr)
				##print xml
				#print strr
		except Exception as ex:
			##print ex
			pass
		##raw_input('--')



	#raw_input('----88')
	#print strr
	#raw_input('=====7')
	pass


def initiatesysmon():
	global treestore,searchfor,treefromsysmonready
	#searchfor=pid
	evtxfile=r'C:\Windows\System32\winevt\Logs\Microsoft-Windows-Sysmon%4Operational.evtx'
	#for now
	#evtxfile=r'Microsoft-Windows-Sysmon%4Operational.evtx'

	fv=open(r'C:\ransomtesting\internals'+os.sep+'sysmonxml.exe','w')

	with open(evtxfile, 'r') as f:

		with contextlib.closing(mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ)) as buf:

			fh = FileHeader(buf, 0x0)

			###print "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\" ?>"
			#fv.write("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\" ?>"+"\n")
			###print "<Events>"
			#fv.write("<Events>"+"\n")

			for xml, record in evtx_file_xml_view(fh):

				###print xml
				#fv.write(xml)
				maketree(xml)

			###print "</Events>"
			#fv.write("</Events>")
	for tt in treestore:
		fv.write(str(tt)+'\n')
	fv.close()
	treefromsysmonready=1



def prprocesscsv(filenamea):
	import csv
	findingslistafterprocessing=[]
	with open(filenamea+'.csv','rb') as f:
		 reader=csv.reader(f)
		 for row in reader:
				#print row
				if row[3]=='WriteFile':
				   try:
					   ju=row[4].index('_crypto')
					   findingslistafterprocessing.append(row)
				   except:
					   pass
				
				#if row[5]=='Delete: True':
				if row[3]=='SetDispositionInformationFile':
					try:
						ju=row[4].index('_crypto')
						findingslistafterprocessing.append(row)
					except:
						pass
				if row[3]=='Process Create':
				   findingslistafterprocessing.append(row)


	gg=open(r'C:\ransomtesting\internals'+os.sep+'proc.exe','a+')
	for i in findingslistafterprocessing:
		for jj in i:
			try:
				gg.write(str(jj)+' ')
			except:
				pass
		gg.write('\n')
	gg.close()			 


def pr2csv_prcheck(filetimeandname):
	#Tue Nov 21 12:04:19 2017$#$test-1.PML
	filetimeandname=filetimeandname.split('$#$')
	filetimeandname=filetimeandname[1]
	filetimeandname=filetimeandname.split('.')
	filetimeandname=filetimeandname[0]
	# now convert pml to csv
	os.system(r'C:\ransomtesting\internals'+os.sep+r'procmon.exe /AcceptEula /Quiet /Minimized /OpenLog test.pml /SaveAs '+r'C:\ransomtesting\internals'+os.sep+filetimeandname+'.csv')
	return filetimeandname

def prcheck():
	global treefromsysmonready,deletedbyprocmon
	# checking no of pml files sorted by date and time
	filelist=[]
	# path to the directory (relative or absolute)
	dirpath = r'C:\ransomtesting\internals'

	# get all entries in the directory w/ stats
	entries = (os.path.join(dirpath, fn) for fn in os.listdir(dirpath))
	entries = ((os.stat(path), path) for path in entries)

	# leave only regular files, insert creation date
	entries = ((stat[ST_CTIME], path)
			   for stat, path in entries if S_ISREG(stat[ST_MODE]))

	#NOTE: on Windows `ST_CTIME` is a creation date 
	#  but on Unix it could be something else
	#NOTE: use `ST_MTIME` to sort by a modification date

	for cdate, path in sorted(entries):
		filetiming=time.ctime(cdate)+'$#$'+os.path.basename(path)
		filelist.append(filetiming)

	for i in reversed(filelist):
		#print i
		try:
			i.index('.PML')
			print i
			filenamee=pr2csv_prcheck(i)
			raw_input('converted to csv')
			print filenamee # converted to csv at this stage
			# time to search for the malware
			prprocesscsv(filenamee) # this gives me all writefile,deleted and process create activity and saved to proc.txt
			raw_input('got all req event from procmon')


		except Exception as ex:
			#print ex
			pass

	
	# i got the writefile,deleted and process create from procmon, now its time to search the pid value of malware
	raw_input('going to open proc')
	fl=open(r'C:\ransomtesting\internals'+os.sep+'proc.exe','r') # based on getting the pid, get tree from sysmon
	#processing sysmon logs
	pidprocessed=[]
	for kk in fl.readlines():
		#2:36:49.4422360 PM drpbx.exe 3652 WriteFile C:\Users\Hemant\Desktop\_crypto.fun SUCCESS Offset: 0, Length: 32, Priority: Normal 
		#12:03:36.3317503 PM drpbx.exe 2700 SetDispositionInformationFile C:\Users\Hemant\Desktop\_crypto SUCCESS Delete: True
		# first now getting the writefile event
		kk=kk.split(' ')
		if kk[4]=='WriteFile':
			try:
				kk[5].index('_crypto')
				susprocesspid=kk[3]
				susprocesspid=susprocesspid.split('.')
				susprocesspid=susprocesspid[0]
				print 'writefile'
				print kk
				print susprocesspid
				if susprocesspid in pidprocessed:
					print 'Already Processed..'
				else:
					pidprocessed.append(susprocesspid)
					# delete the process and its parent immediately
					#TODO
					deletedbyprocmon=1
					#########################################
					## now wait for sysmon function to be ready with its tree information
					while True:
						if treefromsysmonready==1:
							raw_input('initating gettree on it..')
							gettree(susprocesspid)
							raw_input('--')
							break
						else:
							time.sleep(5)
			except:
				pass
		elif kk[4]=='SetDispositionInformationFile':
			try:
				kk[5].index('_crypto')
				susprocesspid=kk[3]
				susprocesspid=susprocesspid.split('.')
				susprocesspid=susprocesspid[0]
				print 'SetDispositionInformationFile'
				print kk
				print susprocesspid
				if susprocesspid in pidprocessed:
					print 'Already Processed..'
				else:
					pidprocessed.append(susprocesspid)
					# delete the process and its parent immediately
					#TODO
					deletedbyprocmon=1
					#########################################
					## now wait for sysmon function to be ready with its tree information
					while True:
						if treefromsysmonready==1:
							raw_input('initating gettree on it..')
							gettree(susprocesspid)
							raw_input('--')
							break
						else:
							time.sleep(5)
			except:
				pass

def deletedbyhandles():
	global treefromsysmonready,deletedbyhandles
	susphandleprocess=[]
	susname=[]
	currentpid=''
	currentname=''
	f=open(r'C:\ransomtesting\internals'+os.sep+'handleinfectdout.exe','r')
	listofusername=[]
	import os
	# get username folder lisitng
	from glob import glob
	a=glob(r"C:\Users\*")
	for i in a:
	  if os.path.isdir(i)==True:
	    try:
	      #print i
	      #raw_input('---')
	      if i!=r'C:\Users\All Users':
	        #delete this afterwards
	        try:
	          i.index('hemant.g.kumar')
	          i=i.replace('hemant.g.kumar','Hemant')
	          listofusername.append(i)
	        except:
	          listofusername.append(i)
	        #################
	        
	    except:
	      pass

	#print listofusername


	for ju in f.readlines():
	  #raw_input('--')
	  #print ju
	  ju=ju.strip()
	  
	  try:
	    ju.index('---------------------------------------------')
	    currentpid=''
	    currentname=''
	    continue
	  except:
	    pass

	  try:
	    ju.index('pid:')
	    gf=ju.split(' ')
	    currentpid=gf[2]
	    currentname=gf[0]
	  except:
	    pass
	  #print currentpid
	  if currentpid!='':
	    try:
	      for uy in listofusername:
	        ##print 'checking Desktop'
	        #print uy
	        try:
	          #print uy+os.sep+'Desktop'
	          ju.index(uy+os.sep+'Desktop')

	          if currentpid in susphandleprocess:
	            pass
	          else:
	            susphandleprocess.append(currentpid)
	            susname.append(currentname)
	            #print currentpid,currentname,ju,'1'

	        except Exception as ex:
	          #print ex
	          pass
	        ##print 'checking download'
	        try:
	          ju.index(uy+os.sep+'Documents')
	          if currentpid in susphandleprocess:
	            pass
	          else:
	            susphandleprocess.append(currentpid)
	            susname.append(currentname)
	            #print currentpid,currentname,ju,'2'
	        except Exception as ex:
	          #print ex
	          pass
	        try:
	          ju.index(uy+os.sep+'Downloads')
	          if currentpid in susphandleprocess:
	            pass
	          else:
	            susphandleprocess.append(currentpid)
	            susname.append(currentname)
	            #print currentpid,currentname,ju,'3'
	        except Exception as ex:
	          #print ex
	          pass
	        """
	        try:
	          ju.index(uy)
	          if currentpid in susphandleprocess:
	            pass
	          else:
	            susphandleprocess.append(currentpid)
	            susname.append(currentname)
	            #print currentpid,currentname,ju,'4'
	        except Exception as ex:
	          #print ex
	          pass
	        """
	    except Exception as ex:
	      #print ex
	      pass
	    """
	    try:
	      ju.index('C:')
	      if currentpid in susphandleprocess:
	        pass
	      else:
	        susphandleprocess.append(currentpid)
	        susname.append(currentname)
	        #print currentpid,currentname,ju,'5'
	    except:
	      pass
	    """

	f.close()
	print susphandleprocess
	print susname
	for kn in susphandleprocess:
		print kn
		try:
			os.system('Taskkill /PID '+str(kn)+' /F')
			raw_input('Teminated successfully..')
			deletedbyhandles=1
		except Exception as ex:
			print ex










def initiatehandles():
	try:
		os.system(r'C:\ransomtesting\internals'+os.sep+'handle64.exe * /accepteula> '+r'C:\ransomtesting\internals'+os.sep+r'handleme.exe')
	except Exception as ex:
		print ex
		pass
	while True:
		if deletedbyprocmon==2:
			deletedbyhandles()
		else:
			time.sleep(5)
	while True:
		if treefromsysmonready==1:
			raw_input('initating gettree on it..')
			gettree(susprocesspid)
			raw_input('--')
			break
		else:
			time.sleep(5)

def deletetop5sysmon():
	# will write code later if needed
	pass


import ctypes
import threading

class myThread (threading.Thread):

	def __init__(self,name):
		threading.Thread.__init__(self)
		self.name = name
	def run(self):
		executeforensics(self.name)
		
# info1: procmon should delete the malware as soon as he finds it, this code is pending as of now 
# info2: sysmon is processed simulataneously and when procmon is done with his work, sysmon tree is processed to kill the malware and its parent 
# handles : it should get the handles but should wait for the procmon to set flag whether it was able to delete the malware

def executeforensics(name):
	global deletedbyprocmon,deletedbyhandles
	if name=='procmon':
		prcheck()
		if deletedbyprocmon!=1:
			deletedbyprocmon=2 # 2 tells that procmon failed to deinfect, now handles will try
	if name=='sysmon':
		initiatesysmon()
	if name=='handles':
		initiatehandles()
		if deletedbyhandles!=1:
			deletedbyhandles=2 # 2 tells that handles also failed, so mftprocessing please help
	if name=='deletetop5sysmon':
		deletetop5sysmon()


### code will come here that will hint malware detected
#TODO or call mainc(), i guess mainc will be better
######################################################
def mainc():
	raw_input('check procmon, handle are in correct place for now....')

	threadLock = threading.Lock()
	threads = []

	# Create new threads
	thread1 = myThread("procmon")
	thread2 = myThread("sysmon")
	thread3 = myThread("handles")
	thread4 = myThread("deletetop5sysmon")


	# Start new Threads
	thread1.start()
	thread2.start()
	thread3.start()
	thread4.start()



	# Add threads to thread list
	threads.append(thread1)
	threads.append(thread2)
	threads.append(thread3)
	threads.append(thread4)

	# Wait for all threads to complete
	for t in threads:
		t.join()
	print "Exiting Main Thread"


	"""
	# scenario you got hit in procmon and then stopping the malware and its parent using sysmon

	prcheck()

	# sceanrio you did not get in procmon

	# TODO getting handles info ,sysmon to xml conversion ,autorun list before diving into procmon
	"""

mainc()