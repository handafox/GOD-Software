import os
import subprocess
from stat import S_ISREG, ST_CTIME, ST_MODE
import os, sys, time
import mmap

import contextlib

import argparse

from Evtx.Evtx import FileHeader

from Evtx.Views import evtx_file_xml_view
import time
treestore=[]
searchfor='' # nouse
strr=''

searchitem='' # stores the actual suspicious pid

processidtodelete=[]
processname=[]

getparentname=''
count=1

treefromsysmonready=0

deletedbyprocmon=0
deletedbyhandles=0
try:
	os.system(r'mkdir "C:\ransomtesting\internals\quarantine"')
except:
	pass


susphandleprocess=[]
import psutil
os.chdir(r'C:\ransomtesting\internals')
from shutil import copyfile
import datetime

def killme(pid):
	try:
		os.system('Taskkill /PID '+str(pid)+' /F')
	except:
		pass
	pass

def quarantinebyname(nameofp):
	gth=open(r"C:\ransomtesting\internals\quarantine\quarantinelog.exe",'a+')
	try:
		nameofprocecss=nameofp
		print nameofprocecss,'--quarantinebyname'
		try:
			try:
				nameofprocecss.index('ransomtesting')# just to hinder deleting any ransomtesting file, but will remove and make it random in future
				return 1
			except:
				pass
			if nameofprocecss.startswith(r'C:\Windows\System32\svchost.exe'): # only to deal with svchost
				pass
			elif nameofprocecss.startswith(r'System'): # only to deal with svchost
				pass
			elif nameofprocecss.startswith(r'C:\Windows\System32'): # don't delete any process resiiidng in system32 folder
				pass
			elif nameofprocecss.startswith(r'C:\ransomtesting'): # don't delete any process resiiidng in system32 folder
				pass
			elif nameofprocecss.startswith(r'C:\Windows\explorer.exe'): # don't delete any process resiiidng in system32 folder
				pass
			else:
				# saving in quartine fodler
				try:
					klj=nameofprocecss
					klj=klj.split(os.sep)
					klj=klj[len(klj)-1]# get the process name without path
					klj=klj.split('.')
					klj=klj[0]
					klj=str(klj)
					sxs=datetime.datetime.now()
					sxs=str(sxs)
					sxs=sxs.replace('-','_')
					sxs=sxs.replace(':','_')
					sxs=sxs.replace(' ','$$')
					sxs=sxs.split('.')
					sxs=str(sxs[0])
					klj=klj+'#$'+sxs#new processnamewithdate
					copyfile(nameofprocecss,r"C:\ransomtesting\internals\quarantine"+os.sep+klj)
					print r"C:\ransomtesting\internals\quarantine"+os.sep+klj,'copied'
					gth.write(klj+'#$#@'+str(nameofprocecss)+'\n')
					try:
						print 'trying to delete by name..',nameofprocecss
						os.system('del /F /Q /A '+nameofprocecss)
					except Exception as ex:
						print ex
						pass
				except:
					pass
		except:
			pass

	except:
		pass
	gth.close()

def quarantine(pid):
	"""
	try:
		os.system(r'mkdir "C:\ransomtesting\internals\quarantine"')
	except:
		pass
	"""
	try:
		p=psutil.Process(pid)
	except Exception as ex:
		return

	gth=open(r"C:\ransomtesting\internals\quarantine\quarantinelog.exe",'a+')
	
	try:
		nameofprocecss=p.exe()
		print nameofprocecss,'--'
		try:
			try:
				nameofprocecss.index('ransomtesting')# just to hinder deleting any ransomtesting file, but will remove and make it random in future
				return 1
			except:
				pass
			if nameofprocecss.startswith(r'C:\Windows\System32\svchost.exe'): # only to deal with svchost
				parentid=p.ppid()
				parentid=psutil.Process(parentid)
				nameofparentprocess=parentid.exe()
				if nameofparentprocess.startswith(r'C:\Windows\System32\services.exe'):
					pass
				else:
					# saving in quartine fodler
						
					try:
						klj=nameofprocecss
						klj=klj.split(os.sep)
						klj=klj[len(klj)-1]# get the process name without path
						klj=klj.split('.')
						klj=klj[0]
						klj=str(klj)
						sxs=datetime.datetime.now()
						sxs=str(sxs)
						sxs=sxs.replace('-','_')
						sxs=sxs.replace(':','_')
						sxs=sxs.replace(' ','$$')
						sxs=sxs.split('.')
						sxs=str(sxs[0])
						klj=klj+'#$'+sxs#new processnamewithdate
						copyfile(nameofprocecss,r"C:\ransomtesting\internals\quarantine"+os.sep+klj)
						gth.write(klj+'#$#@'+str(nameofprocecss)+'\n')
					except:
						pass
					killme(pid)
			elif nameofprocecss.startswith(r'C:\Windows\System32'): # don't delete any process resiiidng in system32 folder
				pass
			elif nameofprocecss.startswith(r'C:\ransomtesting'): # don't delete any process resiiidng in system32 folder
				pass
			elif nameofprocecss.startswith(r'C:\Windows\explorer.exe'): # don't delete any process resiiidng in system32 folder
				pass
			elif nameofprocecss.startswith(r'System'): # don't delete any process resiiidng in system32 folder
				pass
			else:
				# saving in quartine fodler
				try:
					klj=nameofprocecss
					klj=klj.split(os.sep)
					klj=klj[len(klj)-1]# get the process name without path
					klj=klj.split('.')
					klj=klj[0]
					klj=str(klj)
					sxs=datetime.datetime.now()
					sxs=str(sxs)
					sxs=sxs.replace('-','_')
					sxs=sxs.replace(':','_')
					sxs=sxs.replace(' ','$$')
					sxs=sxs.split('.')
					sxs=str(sxs[0])
					klj=klj+'#$'+sxs#new processnamewithdate
					copyfile(nameofprocecss,r"C:\ransomtesting\internals\quarantine"+os.sep+klj)
					gth.write(klj+'#$#@'+str(nameofprocecss)+'\n')
				except:
					pass

				killme(pid)
				try:
					print 'trying to delete',nameofprocecss
					os.system('del /F /Q /A '+nameofprocecss)
				except Exception as ex:
					print ex
					pass
		except:
			pass

	except:
		pass
	gth.close()
	pass

def processme2tree(line):
	global searchitem,processname,processidtodelete,getparentname,count
	#print 'searchitem:',searchitem
	splitinfo=line.split('_$#_')
	foundsearchitem=0
	if count==1:
		kl=splitinfo[0]
		try:
			kl.index(searchitem)
			foundsearchitem=1
		except:
			pass
	elif count==0:
		kl=splitinfo[0]
		try:
			if kl==searchitem:
				foundsearchitem=1
		except:
			pass
	if foundsearchitem==1 and count==1: # first time
		processidtodelete.append(splitinfo[0])
		processname.append(splitinfo[1])
		processidtodelete.append(splitinfo[2])
		processname.append(splitinfo[3])
		#getparentname=splitinfo[3]
		#getparentname=getparentname.split(os.sep)# this get the name
		#getparentname=getparentname[len(getparentname)-1]
		getparentname=splitinfo[2] # its better to get the parent id
		searchitem=getparentname
		#print '---------------------------------------'
		#print line
		#print '-----'
		#print searchitem
		#print '------------'
		#print processname
		#print '-------------------'
		#print processidtodelete
		#print '----------------------------'
		#print splitinfo
		#print '-----------------------------------'
		
		###raw_input(' ')
		count=0
	elif foundsearchitem==1 and count==0: # second time n going..
		#processidtodelete.append(splitinfo[0])
		#processname.append(splitinfo[1])
		processidtodelete.append(splitinfo[2])
		processname.append(splitinfo[3])
		#getparentname=splitinfo[3]
		#getparentname=getparentname.split(os.sep)# this get the name
		#getparentname=getparentname[len(getparentname)-1]
		getparentname=splitinfo[2] # its better to get the parent id
		searchitem=getparentname
		#print '---------------------------------------'
		#print line
		#print '-----'
		#print searchitem
		#print '------------'
		#print processname
		#print '-------------------'
		#print processidtodelete
		#print '----------------------------'
		#print splitinfo
		#print '-----------------------------------'
		###raw_input(' ')
	##print searchitem


def gettree(pid):
	global searchitem,processname,processidtodelete,getparentname,count
	processname=[]
	processidtodelete=[]
	getparentname=''
	searchitem=str(pid)
	for line in reversed(open(r'C:\ransomtesting\internals'+os.sep+"sysmonxml.exe").readlines()):
		processme2tree(line.rstrip())
	print processname
	print processidtodelete

	for kn in processidtodelete:
		print kn
		try:
			quarantine(int(kn))
			#os.system('Taskkill /PID '+str(kn)+' /F')
			#raw_input('Teminated successfully..')
		except Exception as ex:
			print ex
	for kn in processname:
		print kn
		try:
			quarantinebyname(kn)
			#os.system('Taskkill /PID '+str(kn)+' /F')
			#raw_input('Teminated successfully..')
		except Exception as ex:
			print ex
	#raw_input('gettree about to return')

def maketree(xml):
	global treestore,searchfor,strr
	strr=''
	##raw_input('-=-=-=')
	#print xml
	##raw_input('=-=-=-')
	dxc=xml.split('\n')
	#print dxc
	##raw_input('######')
	#dxc=xml
	gotpid=0
	for jkk in dxc:
		##raw_input('44444')
		#print jkk
		##raw_input('77777')
		xml=str(jkk)
		##print xml
		
		
		try:
			xml.index('Qualifiers')
			strr=''
			avar=xml.split('>')
			avar=avar[1].split('<')
			avar=avar[0]
			#strr=avar+'_'
			##print xml
			##print strr
			if avar!='1':
				#print 'next event'
				##raw_input('88888')
				continue
			else:
				gotpid=1
		except Exception as ex:
			#print ex
			#print '1'
			pass
		try:
			if gotpid==1:
				xml.index('"ProcessId')
				strr=''
				avar=xml.split('>')
				avar=avar[1].split('<')
				avar=avar[0]
				strr=avar+'_$#_'
				##print xml
				#print strr
				#gotpid=1
				pass
		except Exception as ex:
			#print ex
			#print '2'
			#gotpid=0
			pass
		try:
			if gotpid==1:
				xml.index('"Image')
				avar=xml.split('>')
				avar=avar[1].split('<')
				avar=avar[0]
				strr=strr+avar+'_$#_'
				##print xml
				#print strr
		except Exception as ex:
			##print ex
			pass
		try:
			if gotpid==1:
				xml.index('ParentProcessId')
				avar=xml.split('>')
				avar=avar[1].split('<')
				avar=avar[0]
				strr=strr+avar+'_$#_'
				##print xml
				#print strr
		except Exception as ex:
			##print ex
			pass
		try:
			if gotpid==1:
				xml.index('ParentImage')
				avar=xml.split('>')
				avar=avar[1].split('<')
				avar=avar[0]
				strr=strr+avar
				treestore.append(strr)
				##print xml
				#print strr
		except Exception as ex:
			##print ex
			pass
		###raw_input('--')



	##raw_input('----88')
	#print strr
	##raw_input('=====7')
	pass

def initiatesysmon():
	global treestore,searchfor,treefromsysmonready
	#searchfor=pid
	evtxfile=r'C:\Windows\System32\winevt\Logs\Microsoft-Windows-Sysmon%4Operational.evtx'
	try:
		from shutil import copyfile
		#copyfile(evtxfile,r"C:\ransomtesting\internals"+os.sep+'sysmonevents.exe')
		os.system(r'C:\Windows\System32'+os.sep+'wevtutil.exe '+r'epl Microsoft-Windows-Sysmon/Operational  C:\ransomtesting\internals\sysmonevents.exe')
		#fgetpathh=r"C:\ransomtesting\internals"+os.sep+'zextr.exe'
		#processtorun=' -extract '+evtxfile+' '+r"C:\ransomtesting\internals"+os.sep+'sysmonevents.exe'
		#os.system(fgetpathh+processtorun)
		pass
	except:
		pass

	#for now
	evtxfile=r"C:\ransomtesting\internals"+os.sep+'sysmonevents.exe'

	fv=open(r'C:\ransomtesting\internals'+os.sep+'sysmonxml.exe','w')

	with open(evtxfile, 'r') as f:

		with contextlib.closing(mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ)) as buf:

			fh = FileHeader(buf, 0x0)

			###print "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\" ?>"
			#fv.write("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\" ?>"+"\n")
			###print "<Events>"
			#fv.write("<Events>"+"\n")

			for xml, record in evtx_file_xml_view(fh):

				###print xml
				#fv.write(xml)
				maketree(xml)

			###print "</Events>"
			#fv.write("</Events>")
	for tt in treestore:
		fv.write(str(tt)+'\n')
	fv.close()
	treefromsysmonready=1



def prprocesscsv(filenamea):
	import csv
	findingslistafterprocessing=[]
	with open(filenamea+'.csv','rb') as f:
		 reader=csv.reader(f)
		 for row in reader:
				#print row
				if row[3]=='WriteFile':
				   try:
					   ju=row[4].index('_crypto')
					   findingslistafterprocessing.append(row)
				   except:
					   pass
				
				#if row[5]=='Delete: True':
				if row[3]=='SetDispositionInformationFile':
					try:
						ju=row[4].index('_crypto')
						findingslistafterprocessing.append(row)
					except:
						pass
				if row[3]=='Process Create':
				   findingslistafterprocessing.append(row)


	gg=open(r'C:\ransomtesting\internals'+os.sep+'proc.exe','a+')
	for i in findingslistafterprocessing:
		for jj in i:
			try:
				gg.write(str(jj)+' ')
			except:
				pass
		gg.write('\n')
	gg.close()			 


def pr2csv_prcheck(filetimeandname):
	#Tue Nov 21 12:04:19 2017$#$test-1.PML
	filetimeandname=filetimeandname.split('$#$')
	filetimeandname=filetimeandname[1]
	filetimeandname=filetimeandname.split('.')
	filetimeandname=filetimeandname[0]
	# now convert pml to csv
	os.system(r'C:\ransomtesting\internals'+os.sep+r'procmon.exe /AcceptEula /Quiet /Minimized /OpenLog '+filetimeandname+'.pml /SaveAs '+r'C:\ransomtesting\internals'+os.sep+filetimeandname+'.csv')
	return filetimeandname

def prcheck():
	global treefromsysmonready,deletedbyprocmon
	# checking no of pml files sorted by date and time
	filelist=[]
	# path to the directory (relative or absolute)
	gotpmlinsystem32=0

	dirpath = r'C:\windows\system32'

	# get all entries in the directory w/ stats
	entries = (os.path.join(dirpath, fn) for fn in os.listdir(dirpath))
	entries = ((os.stat(path), path) for path in entries)

	# leave only regular files, insert creation date
	entries = ((stat[ST_CTIME], path)
			   for stat, path in entries if S_ISREG(stat[ST_MODE]))

	#NOTE: on Windows `ST_CTIME` is a creation date 
	#  but on Unix it could be something else
	#NOTE: use `ST_MTIME` to sort by a modification date

	for cdate, path in sorted(entries):
		filetiming=time.ctime(cdate)+'$#$'+os.path.basename(path)
		filelist.append(filetiming)
	print filelist
	time.sleep(5)

	for i in reversed(filelist):
		#print i
		try:
			i.index('.PML')
			gotpmlinsystem32=1
			print i
			filenamee=pr2csv_prcheck(i)
			#raw_input('converted to csv')
			print filenamee # converted to csv at this stage
			# time to search for the malware
			prprocesscsv(filenamee) # this gives me all writefile,deleted and process create activity and saved to proc.txt
			#raw_input('got all req event from procmon')


		except Exception as ex:
			#print ex
			pass

	if gotpmlinsystem32==0:

		dirpath = r'C:\ransomtesting\internals'

		# get all entries in the directory w/ stats
		entries = (os.path.join(dirpath, fn) for fn in os.listdir(dirpath))
		entries = ((os.stat(path), path) for path in entries)

		# leave only regular files, insert creation date
		entries = ((stat[ST_CTIME], path)
				   for stat, path in entries if S_ISREG(stat[ST_MODE]))

		#NOTE: on Windows `ST_CTIME` is a creation date 
		#  but on Unix it could be something else
		#NOTE: use `ST_MTIME` to sort by a modification date

		for cdate, path in sorted(entries):
			filetiming=time.ctime(cdate)+'$#$'+os.path.basename(path)
			filelist.append(filetiming)
		print filelist

		for i in reversed(filelist):
			#print i
			try:
				i.index('.PML')
				print i
				filenamee=pr2csv_prcheck(i)
				#raw_input('converted to csv')
				print filenamee # converted to csv at this stage
				# time to search for the malware
				prprocesscsv(filenamee) # this gives me all writefile,deleted and process create activity and saved to proc.txt
				#raw_input('got all req event from procmon')


			except Exception as ex:
				#print ex
				pass

	
	# i got the writefile,deleted and process create from procmon, now its time to search the pid value of malware
	#raw_input('going to open proc')
	try:
		fl=open(r'C:\ransomtesting\internals'+os.sep+'proc.exe','r') # based on getting the pid, get tree from sysmon
		#processing sysmon logs
		pidprocessed=[]
		for kk in fl.readlines():
			print 'inside procmon loop'
			#2:36:49.4422360 PM drpbx.exe 3652 WriteFile C:\Users\Hemant\Desktop\_crypto.fun SUCCESS Offset: 0, Length: 32, Priority: Normal 
			#12:03:36.3317503 PM drpbx.exe 2700 SetDispositionInformationFile C:\Users\Hemant\Desktop\_crypto SUCCESS Delete: True
			# first now getting the writefile event
			kk=kk.split(' ')
			if kk[4]=='WriteFile':
				try:
					kk[5].index('_crypto')
					susprocesspid=kk[3]
					susprocesspid=susprocesspid.split('.')
					susprocesspid=susprocesspid[0]
					print 'writefile'
					print kk
					print susprocesspid
					if susprocesspid in pidprocessed:
						print 'Already Processed..'
					else:
						pidprocessed.append(susprocesspid)
						# delete the process and its parent immediately
						#TODO
						deletedbyprocmon=1
						#########################################
						## now wait for sysmon function to be ready with its tree information
						while True:
							if treefromsysmonready==1:
								#raw_input('initating gettree on it..')
								quarantine(int(susprocesspid))
								gettree(susprocesspid)
								#raw_input('--')
								break
							else:
								time.sleep(5)
				except:
					pass
			elif kk[4]=='SetDispositionInformationFile':
				try:
					kk[5].index('_crypto')
					susprocesspid=kk[3]
					susprocesspid=susprocesspid.split('.')
					susprocesspid=susprocesspid[0]
					print 'SetDispositionInformationFile'
					print kk
					print susprocesspid
					if susprocesspid in pidprocessed:
						print 'Already Processed..'
					else:
						pidprocessed.append(susprocesspid)
						# delete the process and its parent immediately
						#TODO
						deletedbyprocmon=1
						#########################################
						## now wait for sysmon function to be ready with its tree information
						while True:
							if treefromsysmonready==1:
								quarantine(int(susprocesspid))
								#raw_input('initating gettree on it..')
								gettree(susprocesspid)
								#raw_input('--')
								break
							else:
								time.sleep(5)
				except:
					pass
		else:
			print 'loop completed of procmon...'
	except:
		print 'Procmon failed..'
		pass

def deletedbyhandles():
	global treefromsysmonready,deletedbyhandles,susphandleprocess
	print 'in deletedbyhandles'
	#susphandleprocess=[]
	susname=[]
	currentpid=''
	currentname=''
	f=open(r'C:\ransomtesting\internals'+os.sep+'handleme.exe','r')
	listofusername=[]
	#import os
	# get username folder lisitng
	from glob import glob
	a=glob(r"C:\Users\*")
	for i in a:
	  if os.path.isdir(i)==True:
	    try:
	      #print i
	      ##raw_input('---')
	      if i!=r'C:\Users\All Users':
	        #delete this afterwards
	        try:
	          #i.index('hemant.g.kumar')
	          #i=i.replace('hemant.g.kumar','Hemant')
	          listofusername.append(i)
	        except:
	          listofusername.append(i)
	        #################
	        
	    except:
	      pass

	print listofusername,'listofusername'


	for ju in f.readlines():
	  ##raw_input('--')
	  #print ju
	  ju=ju.strip()
	  
	  try:
	    ju.index('---------------------------------------------')
	    currentpid=''
	    currentname=''
	    continue
	  except:
	    pass

	  try:
	    ju.index('pid:')
	    gf=ju.split(' ')
	    currentpid=gf[2]
	    currentname=gf[0]
	  except:
	    pass
	  #print currentpid
	  if currentpid!='':
	    try:
	      for uy in listofusername:
	        ##print 'checking Desktop'
	        print uy
	        try:
	          #print uy+os.sep+'Desktop'
	          ju.index(uy+os.sep+'Desktop')

	          if currentpid in susphandleprocess:
	            pass
	          else:
	            susphandleprocess.append(currentpid)
	            susname.append(currentname)
	            #print currentpid,currentname,ju,'1'

	        except Exception as ex:
	          #print ex
	          pass
	        ##print 'checking download'
	        try:
	          ju.index(uy+os.sep+'Documents')
	          if currentpid in susphandleprocess:
	            pass
	          else:
	            susphandleprocess.append(currentpid)
	            susname.append(currentname)
	            #print currentpid,currentname,ju,'2'
	        except Exception as ex:
	          #print ex
	          pass
	        try:
	          ju.index(uy+os.sep+'Downloads')
	          if currentpid in susphandleprocess:
	            pass
	          else:
	            susphandleprocess.append(currentpid)
	            susname.append(currentname)
	            #print currentpid,currentname,ju,'3'
	        except Exception as ex:
	          #print ex
	          pass
	        """
	        try:
	          ju.index(uy)
	          if currentpid in susphandleprocess:
	            pass
	          else:
	            susphandleprocess.append(currentpid)
	            susname.append(currentname)
	            #print currentpid,currentname,ju,'4'
	        except Exception as ex:
	          #print ex
	          pass
	        """
	    except Exception as ex:
	      #print ex
	      pass
	    """
	    try:
	      ju.index('C:')
	      if currentpid in susphandleprocess:
	        pass
	      else:
	        susphandleprocess.append(currentpid)
	        susname.append(currentname)
	        #print currentpid,currentname,ju,'5'
	    except:
	      pass
	    """

	f.close()
	print susphandleprocess
	print susname
	for kn in susphandleprocess:
		print kn
		try:
			quarantine(int(kn))
			#os.system('Taskkill /PID '+str(kn)+' /F')
			#raw_input('Teminated successfully..')
			deletedbyhandles=1
		except Exception as ex:
			print ex

def initiatehandles():
	global susphandleprocess,deletedbyprocmon,treefromsysmonready
	try:
		os.system(r'C:\ransomtesting\internals'+os.sep+'handle64.exe  /accepteula> '+r'C:\ransomtesting\internals'+os.sep+r'handleme.exe')
		print 'got the handles..'
	except Exception as ex:
		print ex
		pass
	# commenting this block for now, i am thinking lets initates handles deinfection irrespective of procmon, let see how it works
	"""
	while True:
		#if deletedbyprocmon==2:
		if deletedbyprocmon==2:
			print 'going to delete by handles..'
			deletedbyhandles()
			break
		elif deletedbyprocmon==5:
			break
		else:
			print 'waiting for procmon value..',deletedbyprocmon
			time.sleep(5)
	"""
	deletedbyhandles()
	while True:
		if treefromsysmonready==1:
			#raw_input('initating gettree on it..')
			for kn in susphandleprocess:
				print kn
				gettree(kn)
				#raw_input('--')
			break
		else:
			time.sleep(5)

def deletetop5sysmon():
	# will write code later if needed
	pass
"""
def checkautorun():
	fv1=open('infectauto.txt','r')
	fv1s=fv1.read()
	fv1.close()


	fv2=open('whiteauto.txt','r')
	fv2s=fv2.read()
	fv2.close()



	import string
	printable = set(string.printable)
	fv1s=filter(lambda x: x in printable,fv1s)
	fv2s=filter(lambda x: x in printable,fv2s)
	#fv1s=fv1s.split('\r\n')# infected one
	#fv2s=fv1s.split('\r\n')

	listofsofttodel=[]

	fv1s=fv1s.split('\r\n')
	fv2s=fv2s.split('\r\n')

	fv1snospace=[]
	fv2snospace=[]

	for sw1 in fv1s:
		fv1snospace.append(sw1.lstrip())

	for sw1 in fv2s:
		fv2snospace.append(sw1.lstrip())


	for sw1 in fv1snospace:
		if sw1.startswith('c:'+os.sep) and sw1 not in fv2snospace:
			sw1=sw1.replace('\r\n','')
			sw1=sw1.strip()
			listofsofttodel.append(sw1)


	print listofsofttodel

	ed=raw_input("To delete tagged malicious softwares, Press 1 and enter key: ")
	if ed=='1':
		print 'deleting...'
		for jk in listofsofttodel:
			try:
				os.system('del /f '+jk)
				print 'DELETED: '+jk
			except Exception as ex:
				print ex
"""

import ctypes
import threading

class myThread (threading.Thread):

	def __init__(self,name):
		threading.Thread.__init__(self)
		self.name = name
	def run(self):
		executeforensics(self.name)
		
# info1: procmon should delete the malware as soon as he finds it, this code is pending as of now 
# info2: sysmon is processed simulataneously and when procmon is done with his work, sysmon tree is processed to kill the malware and its parent 
# handles : it should get the handles but should wait for the procmon to set flag whether it was able to delete the malware

def executeforensics(name):
	global deletedbyprocmon,deletedbyhandles
	if name=='procmon':
		prcheck()
		print 'returned from procmon...'
		print 'returned from procmon...'
		print 'returned from procmon...'
		print 'returned from procmon...'
		print 'returned from procmon...'
		print 'returned from procmon...'
		print 'returned from procmon...'
		print 'returned from procmon...'
		print 'returned from procmon...'
		print 'returned from procmon...'
		print 'returned from procmon...'
		print 'returned from procmon...'
		print 'returned from procmon...'
		print 'returned from procmon...'
		print 'returned from procmon...'
		print 'returned from procmon...'
		print 'returned from procmon...'
		print 'returned from procmon...'
		print 'returned from procmon...'
		print 'returned from procmon...'

		if deletedbyprocmon!=1:
			deletedbyprocmon=2 # 2 tells that procmon failed to deinfect, now handles will try
		else:
			#os.system(r'start C:\windows\explorer.exe')
			deletedbyprocmon=5# success by procmon
			pass
	if name=='sysmon':
		print 'creating sysmon logs..'
		initiatesysmon()
		pass
	if name=='handles':
		print 'creating handles logs..'
		initiatehandles()
		if deletedbyhandles!=1:
			print 'handles failed..'
			deletedbyhandles=2 # 2 tells that handles also failed, so mftprocessing please help
		else:
			deletedbyhandles=5 # success by handles..
			#os.system(r'start C:\windows\explorer.exe')
			print 'handles successed'
			pass
	if name=='deletetop5sysmon':
		#deletetop5sysmon()
		pass
def takeautorunlist():
	os.system(r'C:\ransomtesting\internals'+os.sep+'autorunsc.exe -a * /accepteula > '+r'C:\ransomtesting'+os.sep+'infectedauto.exe')
	

def deinfectautoruns():
	global gofordeinfection
	time.sleep(20)
	takeautorunlist()
	try:
		#os.system(r'C:\ransomtesting\internals'+os.sep+'autorunsc.exe -a /accepteula > '+r'C:\ransomtesting'+os.sep+'infectedauto.exe')

		commdate='date /T'
		output = subprocess.check_output(commdate,shell=True)
		commtime='time /T'
		output = output.replace('\r\n','')
		nowdate= output
		output = output+'___'+subprocess.check_output(commtime,shell=True)
		output = output.replace('\r\n','')


		def calculatedatediff(y1,m1,d1,y2,m2,d2):
			from datetime import date
			d0 = date(y1, m1, d1)
			d1 = date(y2, m2, d2)
			delta = d1 - d0
			return int(delta.days)
			pass

		# check if 2ndwhitelist date is around 10 dat\ys before than today, then deinfect using that

		if os.path.exists(r"C:\ransomtesting"+os.sep+'concurrenttime.exe')==False: # this means only first whitelist is available
			# 
			#takeautorunlist()

			fv1=open(r"C:\ransomtesting"+os.sep+'infectedauto.exe','r')
			fv1s=fv1.read()
			fv1.close()


			fv2=open(r"C:\ransomtesting"+os.sep+'the1stwhitelistauto.exe','r')
			fv2s=fv2.read()
			fv2.close()



			import string
			printable = set(string.printable)
			fv1s=filter(lambda x: x in printable,fv1s)
			fv2s=filter(lambda x: x in printable,fv2s)
			#fv1s=fv1s.split('\r\n')# infected one
			#fv2s=fv1s.split('\r\n')

			listofsofttodel=[]

			fv1s=fv1s.split('\r\n')
			fv2s=fv2s.split('\r\n')

			fv1snospace=[]
			fv2snospace=[]

			for sw1 in fv1s:
				fv1snospace.append(sw1.lstrip())

			for sw1 in fv2s:
				fv2snospace.append(sw1.lstrip())


			for sw1 in fv1snospace:
				if sw1.startswith('c:'+os.sep) and sw1 not in fv2snospace:
					sw1=sw1.replace('\r\n','')
					sw1=sw1.strip()
					listofsofttodel.append(sw1)


			print listofsofttodel

			for jk in listofsofttodel:
				try:
					jk.index('.exe')
					quarantinebyname(jk)
				except Exception as ex:
					print ex

		else: # need to check 2nd whitelist creation time
			#takeautorunlist()

			fv1=open(r"C:\ransomtesting"+os.sep+'the2ndwhitelistauto.exe','r')
			fv1s=fv1.read()
			fv1.close()


			fv2=open(r"C:\ransomtesting"+os.sep+'the1stwhitelistauto.exe','r')
			fv2s=fv2.read()
			fv2.close()



			import string
			printable = set(string.printable)
			fv1s=filter(lambda x: x in printable,fv1s)
			fv2s=filter(lambda x: x in printable,fv2s)
			#fv1s=fv1s.split('\r\n')# infected one
			#fv2s=fv1s.split('\r\n')

			listofsofttodel=[]

			fv1s=fv1s.split('\r\n')
			fv2s=fv2s.split('\r\n')

			fv1snospace=[]
			fv2snospace=[]

			for sw1 in fv1s:
				fv1snospace.append(sw1.lstrip())

			for sw1 in fv2s:
				fv2snospace.append(sw1.lstrip())


			for sw1 in fv1snospace:
				if sw1.startswith('c:'+os.sep) and sw1 not in fv2snospace:
					sw1=sw1.replace('\r\n','')
					sw1=sw1.strip()
					listofsofttodel.append(sw1)


			print listofsofttodel

			
			for jk in listofsofttodel:
				try:
					jk.index('.exe')
					quarantinebyname(jk)
				except Exception as ex:
					print ex
	except Exception as ex:
		print ex
		raw_input('---------------------')
		pass
	pass
### code will come here that will hint malware detected
#TODO or call mainc(), i guess mainc will be better
######################################################
def mainc():
	#raw_input('check procmon, handle are in correct place for now....')

	threadLock = threading.Lock()
	threads = []

	# Create new threads
	thread1 = myThread("procmon")
	thread2 = myThread("sysmon")
	thread3 = myThread("handles")
	thread4 = myThread("deletetop5sysmon")


	# Start new Threads
	thread1.start()
	thread2.start()
	thread3.start()
	thread4.start()



	# Add threads to thread list
	threads.append(thread1)
	threads.append(thread2)
	threads.append(thread3)
	threads.append(thread4)

	# Wait for all threads to complete
	for t in threads:
		t.join()
	print "Exiting Main Thread"

	deinfectautoruns()
	sys.exit(0)


	"""
	# scenario you got hit in procmon and then stopping the malware and its parent using sysmon

	prcheck()

	# sceanrio you did not get in procmon

	# TODO getting handles info ,sysmon to xml conversion ,autorun list before diving into procmon
	"""
try:
	#os.system(r'C:\ransomtesting\internals'+os.sep+r'procmon.exe /Terminate')
	pass
except:
	pass

